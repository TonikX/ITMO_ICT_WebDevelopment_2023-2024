# Представления

Представления - основная логика нашего сайта. Перейдём в файл `views.py` в нашем приложении и напишем несколько 
необходимых для нас функций.

=== "Регистрация"

    ```Python
    from django.contrib import messages
    from django.contrib.auth import login
    from django.shortcuts import render, redirect
    
    from .forms import RegistrationForm


    --8<-- "laboratory_work_2/flights/views.py:12:23"
    ```

    Если пользователь отправил GET-запрос, ему нужно вывести форму регистрации. Для этого создадим объект формы 
    и вызовем функцию `render`, которая отправит этот объект в наш шаблон `register.html`, отрендерит его
    и вернёт пользователю. 

    Если пользователь отправил POST-запрос, значит он уже заполнил форму и нажал на submit кнопку. 
    В таком случае нам нужно провалидировать введённые им данные. Для этого создадим объект формы регистрации с этими данными 
    (получим их из `request.POST`) и вызовем метод `is_valid()`.

    Если метод вернул `True`, значит все валидации прошли успешно. В таком случае создаём новый объект пользователя, 
    авторизуем его с помощью функции `login()`, отправим ему сообщение об успехе и переведём на страницу просмотра рейсов 
    с помощью функции `redirect`.

    Если метод вернул `False`, значит данные в форме заполнены некорректно. Поэтому мы отправим пользователю соответствующее 
    сообщение и вернём форму с уже введёнными данными так же с помощью функции `render`.

=== "Вход"

    ```Python
    from django.contrib import messages
    from django.contrib.auth import login, authenticate
    from django.contrib.auth.forms import AuthenticationForm
    from django.shortcuts import render, redirect


    --8<-- "laboratory_work_2/flights/views.py:26:42"
    ```

    Для входа нам достаточно встроенной формы авторизации `AuthenticationForm`, воспользуемся ей.

    Если пользователь отправил GET-запрос, вернём ему эту форму через шаблон `login.html`.

    Если же пользователь отправил POST-запрос, так же проверим валидации формы, получим из неё логин и пароль 
    и проверим их корректность с помощью функции `authenticate`. Если проверка успешна, авторизуем пользователя 
    с помощью функции `login`, отправим сообщение об успехе и переведём на страницу просмотра рейсов.

    Если же форма не прошла валидацию или введённые данные не прошли проверку, выведем сообщение с ошибкой и вернём 
    заполненную форму обратно.


=== "Выход"

    ```Python
    from django.contrib import messages
    from django.contrib.auth import logout
    from django.shortcuts import redirect


    --8<-- "laboratory_work_2/flights/views.py:45:48"
    ```

    Самое базовое представление. Вызываем функцию `logout`, отправляем сообщение об успешном выходе и переводим 
    на страницу входа.


=== "Просмотр рейсов"

    ```Python
    from django.contrib.auth.decorators import login_required
    from django.shortcuts import render

    from .models import Flight


    --8<-- "laboratory_work_2/flights/views.py:51:54"
    ```

    С помощью декоратора `#!py3 @login_required` обеспечиваем доступ к этому представлению только для авторизованных 
    пользователей. 

    С помощью ORM обращаемся к модели `Flight` и получаем список рейсов, исключая из него с помощью метода `excluded` 
    те рейсы, на которые у пользователя уже есть бронь, фильтруя с помощью метода `filter` только те рейсы, время отправления 
    которых позже текущего времени, и сортируя их с помощью метода `order_by` по времени отправления.

    Отправляем этот список в функцию `render` вместе с шаблоном `flights_list.html` и отправляем пользователю.


=== "Просмотр броней"

    ```Python
    from django.contrib.auth.decorators import login_required
    from django.shortcuts import render
    from django.utils import timezone

    from .models import Booking


    --8<-- "laboratory_work_2/flights/views.py:57:64"
    ```

    Это представление так же защищаем от неавторизованных пользователей с помощью декоратора `#!py3 @login_required`.

    Для просмотра броней хочется сделать, чтобы была возможность просматривать предстоящие и уже завершённые рейсы. 
    Для этого будем передавать в маршруте название активной вкладки, которое наше представление получит в виде арумента 
    `tab`.

    Если `#!py3 tab == "upcoming"`, то есть просматриваются предстоящие рейсы, с помощью ORM и фильтров будем получать 
    только те брони, которые, в первую очередь, связаны с нашим пользователем и время рейса которых позже текущего.

    В ином случае получаем брони, связанные с нашим пользователем, время рейса которых раньше текущего.

    В шаблон `my_flights.html` отправляем активную вкладку и полученные брони, рендерим и отправляем пользователю.


=== "Бронирование"

    ```Python
    from django.contrib import messages
    from django.contrib.auth.decorators import login_required
    from django.shortcuts import redirect

    from .models import Flight, Booking


    --8<-- "laboratory_work_2/flights/views.py:67:72"
    ```

    Это представление так же защищаем от неавторизованных пользователей с помощью декоратора `#!py3 @login_required`.

    Также это представление должно получить id рейса из маршрута пользователя. С помощью ORM получаем объект выбранного рейса 
    и создаём новую запись в таблице броней, привязав к ней пользователя, отправившего запрос и и полученный рейс.

    Отправляем сообщение об успехе и переводим на страницу просмотра рейсов.


=== "Удаление брони"

    ```Python
    from django.contrib import messages
    from django.contrib.auth.decorators import login_required
    from django.shortcuts import redirect

    from .models import Booking


    --8<-- "laboratory_work_2/flights/views.py:75:80"
    ```

    Представление должно получить id брони, которую планируется удалить, поэтому укажем это в аргументах функции.

    С помощью ORM получим объект этой брони (в случае если она привязана к этому пользователю) и с помощью метода 
    `delete` удалим её.
    
    Затем вернём сообщение об успехе и переведём на вкладку предстоящих рейсов страницы просмотра броней (кнопка 
    для удаления броней будет только на странице предстоящих рейсов, поэтому переводим именно туда).


=== "Отзывы"

    ```Python
    from django.contrib import messages
    from django.contrib.auth.decorators import login_required
    from django.shortcuts import render, redirect
    
    from .forms import FeedbackForm
    from .models import Flight


    --8<-- "laboratory_work_2/flights/views.py:83:96"
    ```

    В этом представлении используем написанную нами форму `FeedbackForm`. Также нам необходим получать id рейса, для которого 
    пишется отзыв, поэтому напишем его в аргументы функции.

    Если пользователь отправил GET-запрос, вернём его отрендеренный шаблон `feedback.html` с пустой формой.

    Если пользователь отправил POST-запрос, провалидируем введённые им данные и в случае успеха создадим объект на основе 
    полученных данных, привяжем к нему пользователя и рейс и сохраним в БД. Отправим сообщение об успехе и переведём 
    на вкладку прошедших рейсов страницы просмотра броней (кнопка для отзывов будет только на странице прошедших рейсов, 
    поэтому переводим именно туда).


=== "Информация о рейсе"

    ```Python
    from django.contrib.auth.decorators import login_required
    from django.shortcuts import render, get_object_or_404

    from .models import Flight


    --8<-- "laboratory_work_2/flights/views.py:99:102"
    ```

    Представление получает id рейса и пытается его найти. Если такого рейса не существует, отправляет ошибку 404, в ином 
    случае отправляем объекта рейса в шаблон `flight_details.html`, рендерит и отправляет пользователю.