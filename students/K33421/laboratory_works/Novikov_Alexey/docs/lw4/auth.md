# Авторизация

Начнём работу с настройки взаимодействия с бэкендом: нужно реализовать получение и сохранение JWT, чтобы затем использовать 
их для доступа к закрытым эндпоинтам. Для этого напишем хранилище Pinia и обёртку над `fetch`:

=== "Хранилище"

    ```js title="stores/auth.store.js"
    --8<-- "laboratory_work_4/src/stores/auth.store.js"
    ```

    Объявим в хранилище четыре переменные: `access`, `access_expiration`, `refresh`, `refresh_expiration`. Помимо access 
    токена, нам нужно хранить refresh токен, чтобы не просить пользователя регулярно авторизовываться. И чтобы понимать, 
    когда нужно обновить токен, будем хранить их время жизни.

    Также объявим несколько "действий", чтобы эти токены получить и сохранить:

    В функции `login` с помощью нашей обёртки на `fetch` отправим POST запрос на эндпоинт авторизации вместе с `code`, 
    полученным при вызове функции, в теле запроса.  
    Сохраним полученные данные как в самом хранилище Pinia, так и в локальном хранилище пользователя, а затем с помощью 
    роутера переведём пользователя на маршрут `/survey`, где будет находиться наш опрос.

    В функции `logout` очистим хранилище Pinia и локальное хранилище пользователя, а затем переведём пользователя 
    на страницу авторизации.

    В функции `updateAccessToken` обновим значения токенов на основе данных, полученных из аргументов функции.


=== "Fetch"

    ```js title="helpers/fetch-wrapper.js"
    --8<-- "laboratory_work_4/src/helpers/fetch-wrapper.js"
    ```

    Вызывать обёртку будем с помощью словаря, где ключи - названием методов, а значения - функции с одноимённым аргументом.

    `request` - основная функция. На вход функция получает URL адрес, на который нужно отправить запрос и тело запроса, если 
    оно необходимо.
    В самой функции мы получаем заголовок с JWT токеном с помощью метода `authHeader` нашей обёртки, конвертируем тело в JSON, 
    а затем вызываем оригинальный метод `fetch` с этими параметрами. Полученный ответ обрабатываем с помощью функции `handleResponse`.

    В функции `refreshToken` отправляем POST запрос на эндпоинт обновления токена с refresh токеном в теле запроса.  
    Если статус ответа - не 200, то вызываем функцию `logout` нашего хранилища. 

    В ином случае парсим ответ и вызываем функцию `updateAccessToken` хранилища, чтобы обновить токены. Также возвращаем 
    access токен.

    В функции `checkAndRefreshToken` получим из хранилища access токен, его время жизни и refresh токен. Проверим, живой ли 
    ещё access токен, и, если нет, - вызовем ранее созданную функцию `refreshToken`. Если же живой, то просто вернём его.

    В функции `authHeader` проверим, авторизован ли пользователь (проверив наличие access токена) и является ли полученный URL 
    адресом нашего бэкенда. Если так, то сформируем заголовок и вернём его, в ином случае ничего не вернём.

    В функции `handleResponse` обработаем полученный ответ: распарсим его и вернём, если полученный статус не входит в 
    статусы ошибки в авторизации (в таком случае нужно разлогинить пользователя).

    